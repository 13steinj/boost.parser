<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Error Handling and Debugging</title>
<link rel="stylesheet" href="../../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.79.1">
<link rel="home" href="../../index.html" title="Chapter 1. Boost.Parser (Proposed)">
<link rel="up" href="../tutorial.html" title="Tutorial">
<link rel="prev" href="callback_parsing.html" title="Callback Parsing">
<link rel="next" href="memory_allocation.html" title="Memory Allocation">
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="spirit-nav">
<a accesskey="p" href="callback_parsing.html"><img src="../../images/prev.png" alt="Prev"></a><a accesskey="u" href="../tutorial.html"><img src="../../images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../images/home.png" alt="Home"></a><a accesskey="n" href="memory_allocation.html"><img src="../../images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_parser__proposed_.tutorial.error_handling_and_debugging"></a><a class="link" href="error_handling_and_debugging.html" title="Error Handling and Debugging">Error
      Handling and Debugging</a>
</h3></div></div></div>
<h5>
<a name="boost_parser__proposed_.tutorial.error_handling_and_debugging.h0"></a>
        <span class="phrase"><a name="boost_parser__proposed_.tutorial.error_handling_and_debugging.error_handling"></a></span><a class="link" href="error_handling_and_debugging.html#boost_parser__proposed_.tutorial.error_handling_and_debugging.error_handling">Error
        handling</a>
      </h5>
<p>
        Boost.Parser has good error reporting built into it. Consider what happens
        when we fail to parse at an expectation point (created using <code class="computeroutput"><span class="keyword">operator</span><span class="special">&gt;()</span></code>).
        If I feed the parser from the <a class="link" href="../extended_examples/parsing_json_with_callbacks.html" title="Parsing JSON With Callbacks">Parsing
        JSON With Callbacks</a> example a file called sample.json containing this
        input (note the unmatched <code class="computeroutput"><span class="char">'['</span></code>):
      </p>
<p>
</p>
<pre class="programlisting">{
    "key": "value",
    "foo": [, "bar": []
}
</pre>
<p>
      </p>
<p>
        This is the error message that is printed to the terminal:
      </p>
<p>
</p>
<pre class="programlisting">sample.json:3:12: error: Expected ']' here:
    "foo": [, "bar": []
            ^
</pre>
<p>
      </p>
<p>
        That message is formatted like the diagnostics produced by Clang and GCC.
        It quotes the line on which the failure occurred, and even puts a caret under
        the exact position at which the parse failed. This error message is suitable
        for many kinds of end-users, and interoperates well with anything that supports
        Clang and/or GCC diagnostics.
      </p>
<p>
        Most of Boost.Parser's error handlers format their diagnostics this way,
        though you are not bound by that. You can make an error handler type that
        does whatever you want, as long as it meets the error handler interface.
        See <code class="computeroutput">error_handler</code> in <a class="link" href="../concepts.html" title="Concepts">Concepts</a>
        for details.
      </p>
<p>
        The Boost.Parser error handlers are:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            <code class="computeroutput"><a class="link" href="../../boost/parser/default_error_handler.html" title="Struct default_error_handler">default_error_handler</a></code>:
            Produces formatted diagnostics like the one above, and prints them to
            <code class="computeroutput">std::cerr</code>. <code class="computeroutput"><a class="link" href="../../boost/parser/default_error_handler.html" title="Struct default_error_handler">default_error_handler</a></code> has
            no associated file name, and both errors and diagnostics are printed
            to <code class="computeroutput">std::cerr</code>. This handler is <code class="computeroutput">constexpr</code>-friendly.
          </li>
<li class="listitem">
            <code class="computeroutput"><a class="link" href="../../boost/parser/stream_error_handler.html" title="Struct stream_error_handler">stream_error_handler</a></code>:
            Produces formatted diagnostics. One or two streams may be used. If two
            are used, errors go to one stream and warnings go to the other. A file
            name can be associated with the parse; if it is, that file name will
            appear in all diagnostics.
          </li>
<li class="listitem">
            <code class="computeroutput"><a class="link" href="../../boost/parser/callback_error_handler.html" title="Struct callback_error_handler">callback_error_handler</a></code>:
            Produces formatted diagnostics. Calls a callback with the diagnostic
            message to report the diagnostic, rather than streaming out the diagnostic.
            A file name can be associated with the parse; if it is, that file name
            will appear in all diagnostics. This handler is useful for recording
            the diagnostics in memory.
          </li>
<li class="listitem">
            <code class="computeroutput"><a class="link" href="../../boost/parser/rethrow_error_handler.html" title="Struct rethrow_error_handler">rethrow_error_handler</a></code>:
            Does nothing but re-throw any exception that it is asked to handle. Its
            <code class="computeroutput">diagnose()</code> member functions are no-ops.
          </li>
</ul></div>
<div class="tip"><table border="0" summary="Tip">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="../../images/tip.png"></td>
<th align="left">Tip</th>
</tr>
<tr><td align="left" valign="top"><p>
          If you want to provide your own error handler, but still want to use the
          same formatting as Boost.Parser error handlers, you can use the functions
          <code class="computeroutput">write_formatted_message()</code> and <code class="computeroutput">write_formatted_expectation_failure_error_message()</code>
          to do that for you.
        </p></td></tr>
</table></div>
<h5>
<a name="boost_parser__proposed_.tutorial.error_handling_and_debugging.h1"></a>
        <span class="phrase"><a name="boost_parser__proposed_.tutorial.error_handling_and_debugging.fixing_ill_formed_code"></a></span><a class="link" href="error_handling_and_debugging.html#boost_parser__proposed_.tutorial.error_handling_and_debugging.fixing_ill_formed_code">Fixing
        ill-formed code</a>
      </h5>
<p>
        Sometimes, during the writing of a parser, you make a simple mistake that
        is diagnosed horrifyingly, due to the high number of template instantiations
        between the line you just wrote and the point of use (usually, the call to
        <code class="computeroutput"><a class="link" href="../../boost/parser/parse_idm20150.html" title="Function template parse">parse()</a></code>). By "sometimes",
        I mean "almost always and many, many times". Boost.Parser has a
        workaround for situations like this. The workaround is to make the ill-formed
        code well-formed in as many circumstances as possible, and then do a runtime
        assert instead.
      </p>
<p>
        Usually, C++ programmers try whenever they can to catch mistakes as early
        as they can. That usually means making as much bad code ill-formed as possible.
        Counter-intuitively, this does not work well in parser combinator situations.
        For an example of just how dramatically different these two debugging scenarios
        can be with Boost.Parser, please see the very long discussion in the <a class="link" href="../rationale.html#boost_parser__proposed_.rationale._classname_alt__boost__parser__none___code__phrase_role__identifier__none__phrase___code___classname__is_weird"><code class="computeroutput"><span class="identifier">none</span></code> is weird</a> section of <a class="link" href="../rationale.html" title="Rationale">Rationale</a>.
      </p>
<p>
        If you are morally opposed to this approach, or just hate fun, good news:
        you can turn off the use of this technique entirely by defining <code class="computeroutput">BOOST_PARSER_NO_RUNTIME_ASSERTIONS</code>.
      </p>
<h5>
<a name="boost_parser__proposed_.tutorial.error_handling_and_debugging.h2"></a>
        <span class="phrase"><a name="boost_parser__proposed_.tutorial.error_handling_and_debugging.runtime_debugging"></a></span><a class="link" href="error_handling_and_debugging.html#boost_parser__proposed_.tutorial.error_handling_and_debugging.runtime_debugging">Runtime
        Debugging</a>
      </h5>
<p>
        Debugging parsers is hard. Any parser above a certain complexity level is
        nearly impossible to debug simply by looking at the parser's code. Stepping
        through the parse in a debugger is even worse. To provide a reasonable chance
        of debugging your parsers, Boost.Parser has a trace mode that you can turn
        on simply by providing an extra parameter to <code class="computeroutput"><a class="link" href="../../boost/parser/parse_idm20150.html" title="Function template parse">parse()</a></code>
        or <code class="computeroutput"><a class="link" href="../../boost/parser/callback_parse_idm20410.html" title="Function template callback_parse">callback_parse()</a></code>:
      </p>
<pre class="programlisting">boost::parser::parse(input, parser, boost::parser::trace::on);
</pre>
<p>
        Every overload of <code class="computeroutput"><a class="link" href="../../boost/parser/parse_idm20150.html" title="Function template parse">parse()</a></code>
        and <code class="computeroutput"><a class="link" href="../../boost/parser/callback_parse_idm20410.html" title="Function template callback_parse">callback_parse()</a></code> takes this final parameter,
        which is defaulted to <code class="computeroutput">boost::parser::trace::off</code>.
      </p>
<p>
        If we trace a substantial parser, we will see a <span class="bold"><strong>lot</strong></span>
        of output. Each code point of the input must be considered, one at a time,
        to see if a certain rule matches. An an example, let's trace a parse using
        the JSON parser from <a class="link" href="../extended_examples/parsing_json.html" title="Parsing JSON">Parsing
        JSON</a>. The input is <code class="computeroutput">"null"</code>. <code class="computeroutput">null</code>
        is one of the types that a Javascript value can have; the top-level parser
        in the JSON parser example is:
      </p>
<pre class="programlisting">auto const value_p_def =
    number | bp::bool_ | null | string | array_p | object_p;
</pre>
<p>
        So, a JSON value can be a number, or a Boolean, a <code class="computeroutput">null</code>, etc.
        During the parse, each alternative will be tried in turn, until one is matched.
        I picked <code class="computeroutput">null</code> because it is relatively close to the beginning
        of the <code class="computeroutput">value_p_def</code> alternative parser. Even so, the output is
        pretty huge. Let's break it down as we go:
      </p>
<p>
</p>
<pre class="programlisting">[begin value; input="null"]
</pre>
<p>
      </p>
<p>
        Each parser is traced as <code class="computeroutput">[begin foo; ...]</code>, then the parsing
        operations themselves, and then <code class="computeroutput">[end foo; ...]</code>. The name of
        a rule is used as its name in the <code class="computeroutput">begin</code> and <code class="computeroutput">end</code>
        parts of the trace. Non-rules have a name that is similar to the way the
        parser looked when you wrote it. Most lines will have the next few code points
        of the input quoted, as we have here (<code class="computeroutput">input="null"</code>).
      </p>
<p>
</p>
<pre class="programlisting">[begin number | bool_ | null | string | ...; input="null"]
</pre>
<p>
      </p>
<p>
        This shows the beginning of the parser <span class="bold"><strong>inside</strong></span>
        the rule <code class="computeroutput">value</code> — the parser that actually does all the
        work. In the example code, this parser is called <code class="computeroutput">value_p_def</code>.
        Since it isn't a rule, we have no name for it, so we show its implementation
        in terms of subparsers. Since it is a bit long, we don't print the entire
        thing. That's why that ellipsis is there.
      </p>
<p>
</p>
<pre class="programlisting">[begin number; input="null"]
  [begin raw[lexeme[ &gt;&gt; ...]][&lt;&lt;action&gt;&gt;]; input="null"]
</pre>
<p>
      </p>
<p>
        Now we're starting to see the real work being done. <code class="computeroutput">number</code> is
        a somewhat complicated parser that does not match <code class="computeroutput">"null"</code>,
        so there's a lot to wade through when following the trace of its attempt
        to do so. One thing to note is that, since we cannot print a name for an
        action, we just print <code class="computeroutput">"&lt;&lt;action&gt;&gt;"</code>. Something
        similar happens when we come to an attribute that we cannot print, because
        it has no stream insertion operation. In that case, <code class="computeroutput">"&lt;&lt;unprintable-value&gt;&gt;"</code>
        is printed.
      </p>
<p>
</p>
<pre class="programlisting">    [begin raw[lexeme[ &gt;&gt; ...]]; input="null"]
      [begin lexeme[-char_('-') &gt;&gt; char_('1', '9') &gt;&gt; ... | ... &gt;&gt; ...]; input="null"]
        [begin -char_('-') &gt;&gt; char_('1', '9') &gt;&gt; *ascii::digit | char_('0') &gt;&gt; -(char_('.') &gt;&gt; ...) &gt;&gt; -( &gt;&gt; ...); input="null"]
          [begin -char_('-'); input="null"]
            [begin char_('-'); input="null"]
              no match
            [end char_('-'); input="null"]
            matched ""
            attribute: &lt;&lt;empty&gt;&gt;
          [end -char_('-'); input="null"]
          [begin char_('1', '9') &gt;&gt; *ascii::digit | char_('0'); input="null"]
            [begin char_('1', '9') &gt;&gt; *ascii::digit; input="null"]
              [begin char_('1', '9'); input="null"]
                no match
              [end char_('1', '9'); input="null"]
              no match
            [end char_('1', '9') &gt;&gt; *ascii::digit; input="null"]
            [begin char_('0'); input="null"]
              no match
            [end char_('0'); input="null"]
            no match
          [end char_('1', '9') &gt;&gt; *ascii::digit | char_('0'); input="null"]
          no match
        [end -char_('-') &gt;&gt; char_('1', '9') &gt;&gt; *ascii::digit | char_('0') &gt;&gt; -(char_('.') &gt;&gt; ...) &gt;&gt; -( &gt;&gt; ...); input="null"]
        no match
      [end lexeme[-char_('-') &gt;&gt; char_('1', '9') &gt;&gt; ... | ... &gt;&gt; ...]; input="null"]
      no match
    [end raw[lexeme[ &gt;&gt; ...]]; input="null"]
    no match
  [end raw[lexeme[ &gt;&gt; ...]][&lt;&lt;action&gt;&gt;]; input="null"]
  no match
[end number; input="null"]
[begin bool_; input="null"]
  no match
[end bool_; input="null"]
</pre>
<p>
      </p>
<p>
        <code class="computeroutput">number</code> and <code class="computeroutput">boost::parser::bool_</code> did not match,
        but <code class="computeroutput">null</code> will:
      </p>
<p>
</p>
<pre class="programlisting">[begin null; input="null"]
  [begin "null" &gt;&gt; attr(null); input="null"]
    [begin "null"; input="null"]
      [begin string("null"); input="null"]
        matched "null"
        attribute:
      [end string("null"); input=""]
      matched "null"
      attribute: null
</pre>
<p>
      </p>
<p>
        Finally, this parser actually matched, and the match generated the attribute
        <code class="computeroutput">null</code>, which is a special value of the type <code class="computeroutput">json::value</code>.
        Since we were matching a string literal <code class="computeroutput">"null"</code>, earlier
        there was no attribute until we reached the <code class="computeroutput">attr(null)</code> parser.
      </p>
<p>
</p>
<pre class="programlisting">        [end "null"; input=""]
        [begin attr(null); input=""]
          matched ""
          attribute: null
        [end attr(null); input=""]
        matched "null"
        attribute: null
      [end "null" &gt;&gt; attr(null); input=""]
      matched "null"
      attribute: null
    [end null; input=""]
    matched "null"
    attribute: null
  [end number | bool_ | null | string | ...; input=""]
  matched "null"
  attribute: null
[end value; input=""]
--------------------
parse succeeded
--------------------
</pre>
<p>
      </p>
<p>
        At the very end of the parse, the trace code prints out whether the top-level
        parse succeeded or failed.
      </p>
<p>
        Some things to be aware of when looking at Boost.Parser trace output:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            There are some parsers you don't know about, because they are not directly
            documented. For instance, <code class="computeroutput">p[a]</code> forms an <code class="computeroutput">action_parser</code>
            containing the parser <code class="computeroutput">p</code> and semantic action <code class="computeroutput">a</code>.
            This is essentially an implementation detail, but unfortunately the trace
            output does not hide this from you.
          </li>
<li class="listitem">
            For a parser <code class="computeroutput">p</code>, the trace-name may be intentionally different
            from the actual structure of <code class="computeroutput">p</code>. For example, in the trace
            above, you see a parser called simply <code class="computeroutput">"null"</code>.
            This parser is actually <code class="computeroutput">boost::parser::omit[boost::parser::string("null")]</code>,
            but what you typically write is just <code class="computeroutput">"null"</code>, so
            that's the name used. There are two special cases like this: the one
            described here for <code class="computeroutput">omit[string]</code>, and another for <code class="computeroutput">omit[char_]</code>.
          </li>
<li class="listitem">
            Since there are no other special cases for how parser names are printed,
            you may see parsers that are unlike what you wrote in your code. In the
            sections about the parsers and combining operations, you will sometimes
            see a parser or combining operation described in terms of an equivalent
            parser. For example, <code class="computeroutput">if_(pred)[p]</code> is described as "Equivalent
            to <code class="computeroutput"><a class="link" href="../../boost/parser/eps.html" title="Global eps">eps</a>(pred)
            &gt;&gt; p</code>". In a trace, you will not see <code class="computeroutput">if_</code>;
            you will see <code class="computeroutput"><a class="link" href="../../boost/parser/eps.html" title="Global eps">eps</a></code>
            and <code class="computeroutput">p</code> instead.
          </li>
<li class="listitem">
            The values of arguments passed to parsers is printed whenever possible.
            Sometimes, a parse argument is not a value itself, but a callable that
            produces that value. In these cases, you'll see the resolved value of
            the parse argument.
          </li>
</ul></div>
</div>
<div class="copyright-footer">Copyright © 2020 T. Zachary Laine<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="callback_parsing.html"><img src="../../images/prev.png" alt="Prev"></a><a accesskey="u" href="../tutorial.html"><img src="../../images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../images/home.png" alt="Home"></a><a accesskey="n" href="memory_allocation.html"><img src="../../images/next.png" alt="Next"></a>
</div>
</body>
</html>
