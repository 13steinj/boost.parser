<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>The Parse Context</title>
<link rel="stylesheet" href="../../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.79.1">
<link rel="home" href="../../index.html" title="Chapter 1. Boost.Parser (Proposed)">
<link rel="up" href="../tutorial.html" title="Tutorial">
<link rel="prev" href="semantic_actions.html" title="Semantic Actions">
<link rel="next" href="rule_parsers.html" title="Rule Parsers">
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="spirit-nav">
<a accesskey="p" href="semantic_actions.html"><img src="../../images/prev.png" alt="Prev"></a><a accesskey="u" href="../tutorial.html"><img src="../../images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../images/home.png" alt="Home"></a><a accesskey="n" href="rule_parsers.html"><img src="../../images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_parser__proposed_.tutorial.the_parse_context"></a><a class="link" href="the_parse_context.html" title="The Parse Context">The
      Parse Context</a>
</h3></div></div></div>
<p>
        Now would be a good time to describe the parse context in some detail. Any
        semantic action that you write will need to use state in the parse context,
        so you need to know what's available.
      </p>
<p>
        The parse context is a class template that maps tag types to values. Key/value
        pairs are "added" to or "removed" from it at different
        times during the parse, by changing the template's parameters, and/or assigning
        over the existing data members. For instance, when a parser <code class="computeroutput"><span class="identifier">p</span></code> with a semantic action <code class="computeroutput"><span class="identifier">a</span></code> succeeds, the context adds the attribute
        <code class="computeroutput"><span class="identifier">p</span></code> produces to the parse context,
        then calls <code class="computeroutput"><span class="identifier">a</span></code>. This is efficient
        to do, because the parse context has only about a dozen data members, and
        each data member is less than or equal to the size of a pointer. Copying
        the entire map when mutating the context is therefore fast. The map itself
        is based on a <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">hana</span></code> map; it involves no memory allocation.
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          All these functions that take the parse context as their first parameter
          will find by found by Argument-Dependent Lookup. You will probably never
          need to qualify them with <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">parser</span><span class="special">::</span></code>.
        </p></td></tr>
</table></div>
<h5>
<a name="boost_parser__proposed_.tutorial.the_parse_context.h0"></a>
        <span class="phrase"><a name="boost_parser__proposed_.tutorial.the_parse_context.accessors_for_data_that_are_always_available"></a></span><a class="link" href="the_parse_context.html#boost_parser__proposed_.tutorial.the_parse_context.accessors_for_data_that_are_always_available">Accessors
        for data that are always available</a>
      </h5>
<p>
        By convention, the names of all Boost.Parser functions that take a parse
        context, and are therefore intended for use inside semantic actions, contain
        a leading underscore.
      </p>
<h5>
<a name="boost_parser__proposed_.tutorial.the_parse_context.h1"></a>
        <span class="phrase"><a name="boost_parser__proposed_.tutorial.the_parse_context._functionname_alt__boost__parser___pass___code__phrase_role__identifier___pass__phrase__phrase_role__special______phrase___code___functionname_"></a></span><a class="link" href="the_parse_context.html#boost_parser__proposed_.tutorial.the_parse_context._functionname_alt__boost__parser___pass___code__phrase_role__identifier___pass__phrase__phrase_role__special______phrase___code___functionname_">_pass()</a>
      </h5>
<p>
        <code class="computeroutput"><a class="link" href="../../boost/parser/_pass.html" title="Function template _pass">_pass()</a></code> returns a reference to a
        <code class="computeroutput"><span class="keyword">bool</span></code> indicating the success
        of failure of the current parse. This can be used to force the current parse
        to pass or fail:
      </p>
<pre class="programlisting"><span class="special">[](</span><span class="keyword">auto</span> <span class="special">&amp;</span> <span class="identifier">ctx</span><span class="special">)</span> <span class="special">{</span>
    <span class="comment">// If the attribute meets this predicate, fail the parse.</span>
    <span class="keyword">if</span> <span class="special">(</span><span class="identifier">some_condition</span><span class="special">(</span><span class="identifier">_attr</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">)))</span>
        <span class="identifier">_pass</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">)</span> <span class="special">=</span> <span class="keyword">false</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
        Note that for a semantic action to be executed, its associated parser must
        already have succeeded. So unless you previously wrote <code class="computeroutput"><span class="identifier">_pass</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">)</span>
        <span class="special">=</span> <span class="keyword">false</span></code>
        within your action, <code class="computeroutput"><span class="identifier">_pass</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">)</span>
        <span class="special">=</span> <span class="keyword">true</span></code>
        does nothing; it's redundant.
      </p>
<h5>
<a name="boost_parser__proposed_.tutorial.the_parse_context.h2"></a>
        <span class="phrase"><a name="boost_parser__proposed_.tutorial.the_parse_context._functionname_alt__boost__parser___begin___code__phrase_role__identifier___begin__phrase__phrase_role__special______phrase___code___functionname____functionname_alt__boost__parser___end___code__phrase_role__identifier___end__phrase__phrase_role__special______phrase___code___functionname__and__functionname_alt__boost__parser___where___code__phrase_role__identifier___where__phrase__phrase_role__special______phrase___code___functionname_"></a></span><a class="link" href="the_parse_context.html#boost_parser__proposed_.tutorial.the_parse_context._functionname_alt__boost__parser___begin___code__phrase_role__identifier___begin__phrase__phrase_role__special______phrase___code___functionname____functionname_alt__boost__parser___end___code__phrase_role__identifier___end__phrase__phrase_role__special______phrase___code___functionname__and__functionname_alt__boost__parser___where___code__phrase_role__identifier___where__phrase__phrase_role__special______phrase___code___functionname_">_begin(), _end()
        and _where()</a>
      </h5>
<p>
        <code class="computeroutput"><a class="link" href="../../boost/parser/_begin.html" title="Function template _begin">_begin()</a></code> and <code class="computeroutput"><a class="link" href="../../boost/parser/_end.html" title="Function template _end">_end()</a></code>
        return the beginning and end of the range that you passed to <code class="computeroutput"><a class="link" href="../../boost/parser/parse_idm20150.html" title="Function template parse">parse()</a></code>, respectively. <code class="computeroutput"><a class="link" href="../../boost/parser/_where.html" title="Function template _where">_where()</a></code> returns a <code class="computeroutput"><a class="link" href="../../boost/parser/subrange.html" title="Struct template subrange">subrange</a></code> indicating the bounds
        of the input matched by the current parse. <code class="computeroutput"><a class="link" href="../../boost/parser/_where.html" title="Function template _where">_where()</a></code>
        can be useful if you just want to parse some text and return a result consisting
        of where certain elements are located, without producing any other attributes.
      </p>
<h5>
<a name="boost_parser__proposed_.tutorial.the_parse_context.h3"></a>
        <span class="phrase"><a name="boost_parser__proposed_.tutorial.the_parse_context._functionname_alt__boost__parser___error_handler___code__phrase_role__identifier___error_handler__phrase__phrase_role__special______phrase___code___functionname_"></a></span><a class="link" href="the_parse_context.html#boost_parser__proposed_.tutorial.the_parse_context._functionname_alt__boost__parser___error_handler___code__phrase_role__identifier___error_handler__phrase__phrase_role__special______phrase___code___functionname_">_error_handler()</a>
      </h5>
<p>
        <code class="computeroutput"><a class="link" href="../../boost/parser/_error_handler.html" title="Function template _error_handler">_error_handler()</a></code> returns a reference to the
        error handler associated with the parser passed to <code class="computeroutput"><a class="link" href="../../boost/parser/parse_idm20150.html" title="Function template parse">parse()</a></code>.
        Any error handler must have the following member functions:
      </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Context</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Iter</span><span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">diagnose</span><span class="special">(</span>
    <span class="identifier">diagnostic_kind</span> <span class="identifier">kind</span><span class="special">,</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">string_view</span> <span class="identifier">message</span><span class="special">,</span>
    <span class="identifier">Context</span> <span class="keyword">const</span> <span class="special">&amp;</span> <span class="identifier">context</span><span class="special">,</span>
    <span class="identifier">Iter</span> <span class="identifier">it</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<p>
      </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Context</span><span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">diagnose</span><span class="special">(</span>
    <span class="identifier">diagnostic_kind</span> <span class="identifier">kind</span><span class="special">,</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">string_view</span> <span class="identifier">message</span><span class="special">,</span>
    <span class="identifier">Context</span> <span class="keyword">const</span> <span class="special">&amp;</span> <span class="identifier">context</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<p>
      </p>
<p>
        If you call the second one, the one without the iterator parameter, it will
        call the first with <code class="computeroutput"><span class="identifier">_where</span><span class="special">(</span><span class="identifier">context</span><span class="special">).</span><span class="identifier">begin</span><span class="special">()</span></code> as the iterator parameter. The one without
        the iterator is the one you will use most often. The one with the explicit
        iterator parameter can be useful in situations where you have messages that
        are related to each other, associated with multiple locations. For instance,
        if you are parsing XML, you may want to report that a close-tag does not
        match its associated open-tag by showing the line where the open-tag was
        found. That may of course not be located anywhere near <code class="computeroutput"><span class="identifier">_where</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">).</span><span class="identifier">begin</span><span class="special">()</span></code>.
        (A description of <code class="computeroutput"><a class="link" href="../../boost/parser/_globals.html" title="Function template _globals">_globals()</a></code>
        is below.)
      </p>
<pre class="programlisting"><span class="special">[](</span><span class="keyword">auto</span> <span class="special">&amp;</span> <span class="identifier">ctx</span><span class="special">)</span> <span class="special">{</span>
    <span class="comment">// Assume we have a std::vector of open tags, and another</span>
    <span class="comment">// std::vector of iterators to where the open tags were parsed, in our</span>
    <span class="comment">// globals.</span>
    <span class="keyword">if</span> <span class="special">(</span><span class="identifier">_attr</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">)</span> <span class="special">!=</span> <span class="identifier">_globals</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">).</span><span class="identifier">open_tags</span><span class="special">.</span><span class="identifier">back</span><span class="special">())</span> <span class="special">{</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">open_tag_msg</span> <span class="special">=</span>
            <span class="string">"Previous open-tag \""</span> <span class="special">+</span> <span class="identifier">_globals</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">).</span><span class="identifier">open_tags</span><span class="special">.</span><span class="identifier">back</span><span class="special">()</span> <span class="special">+</span> <span class="string">"\" here:"</span><span class="special">;</span>
        <span class="identifier">_error_handler</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">).</span><span class="identifier">diagnose</span><span class="special">(</span>
            <span class="identifier">boost</span><span class="special">::</span><span class="identifier">parser</span><span class="special">::</span><span class="identifier">diagnostic_kind</span><span class="special">::</span><span class="identifier">error</span><span class="special">,</span>
            <span class="identifier">open_tag_msg</span><span class="special">,</span>
            <span class="identifier">ctx</span><span class="special">,</span>
            <span class="identifier">_globals</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">).</span><span class="identifier">open_tags_position</span><span class="special">.</span><span class="identifier">back</span><span class="special">());</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">close_tag_msg</span> <span class="special">=</span>
            <span class="string">"does not match close-tag \""</span> <span class="special">+</span> <span class="identifier">_attr</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">)</span> <span class="special">+</span> <span class="string">"\" here:"</span><span class="special">;</span>
        <span class="identifier">_error_handler</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">).</span><span class="identifier">diagnose</span><span class="special">(</span>
            <span class="identifier">boost</span><span class="special">::</span><span class="identifier">parser</span><span class="special">::</span><span class="identifier">diagnostic_kind</span><span class="special">::</span><span class="identifier">error</span><span class="special">,</span>
            <span class="identifier">close_tag_msg</span><span class="special">,</span>
            <span class="identifier">ctx</span><span class="special">);</span>

        <span class="comment">// Explicitly fail the parse.  Diagnostics to not affect parse success.</span>
        <span class="identifier">_pass</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">)</span> <span class="special">=</span> <span class="keyword">false</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">}</span>
</pre>
<h5>
<a name="boost_parser__proposed_.tutorial.the_parse_context.h4"></a>
        <span class="phrase"><a name="boost_parser__proposed_.tutorial.the_parse_context._functionname_alt__boost__parser___report_error___code__phrase_role__identifier___report_error__phrase__phrase_role__special______phrase___code___functionname__and__functionname_alt__boost__parser___report_warning___code__phrase_role__identifier___report_warning__phrase__phrase_role__special______phrase___code___functionname_"></a></span><a class="link" href="the_parse_context.html#boost_parser__proposed_.tutorial.the_parse_context._functionname_alt__boost__parser___report_error___code__phrase_role__identifier___report_error__phrase__phrase_role__special______phrase___code___functionname__and__functionname_alt__boost__parser___report_warning___code__phrase_role__identifier___report_warning__phrase__phrase_role__special______phrase___code___functionname_">_report_error() and _report_warning()</a>
      </h5>
<p>
        There are also some convenience functions that make the above code a little
        less verbose, <code class="computeroutput"><a class="link" href="../../boost/parser/report_error_idm19721.html" title="Function template _report_error">_report_error()</a></code>
        and <code class="computeroutput"><a class="link" href="../../boost/parser/report_warning_idm19733.html" title="Function template _report_warning">_report_warning()</a></code>:
      </p>
<pre class="programlisting"><span class="special">[](</span><span class="keyword">auto</span> <span class="special">&amp;</span> <span class="identifier">ctx</span><span class="special">)</span> <span class="special">{</span>
    <span class="comment">// Assume we have a std::vector of open tags, and another</span>
    <span class="comment">// std::vector of iterators to where the open tags were parsed, in our</span>
    <span class="comment">// globals.</span>
    <span class="keyword">if</span> <span class="special">(</span><span class="identifier">_attr</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">)</span> <span class="special">!=</span> <span class="identifier">_globals</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">).</span><span class="identifier">open_tags</span><span class="special">.</span><span class="identifier">back</span><span class="special">())</span> <span class="special">{</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">open_tag_msg</span> <span class="special">=</span>
            <span class="string">"Previous open-tag \""</span> <span class="special">+</span> <span class="identifier">_globals</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">).</span><span class="identifier">open_tags</span><span class="special">.</span><span class="identifier">back</span><span class="special">()</span> <span class="special">+</span> <span class="string">"\" here:"</span><span class="special">;</span>
        <span class="identifier">_report_error</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">,</span> <span class="identifier">open_tag_msg</span><span class="special">,</span> <span class="identifier">_globals</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">).</span><span class="identifier">open_tag_positions</span><span class="special">.</span><span class="identifier">back</span><span class="special">());</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">close_tag_msg</span> <span class="special">=</span>
            <span class="string">"does not match close-tag \""</span> <span class="special">+</span> <span class="identifier">_attr</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">)</span> <span class="special">+</span> <span class="string">"\" here:"</span><span class="special">;</span>
        <span class="identifier">_report_error</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">,</span> <span class="identifier">close_tag_msg</span><span class="special">);</span>

        <span class="comment">// Explicitly fail the parse.  Diagnostics to not affect parse success.</span>
        <span class="identifier">_pass</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">)</span> <span class="special">=</span> <span class="keyword">false</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">}</span>
</pre>
<p>
        You should use these less verbose functions almost all the time. The only
        time you would want to use <code class="computeroutput"><a class="link" href="../../boost/parser/_error_handler.html" title="Function template _error_handler">_error_handler()</a></code>
        is when you are using a custom error handler, and you want access to some
        part of it's interface besides <code class="computeroutput"><span class="identifier">diagnose</span><span class="special">()</span></code>.
      </p>
<h5>
<a name="boost_parser__proposed_.tutorial.the_parse_context.h5"></a>
        <span class="phrase"><a name="boost_parser__proposed_.tutorial.the_parse_context.accessors_for_data_that_are_only_sometimes_available"></a></span><a class="link" href="the_parse_context.html#boost_parser__proposed_.tutorial.the_parse_context.accessors_for_data_that_are_only_sometimes_available">Accessors
        for data that are only sometimes available</a>
      </h5>
<h5>
<a name="boost_parser__proposed_.tutorial.the_parse_context.h6"></a>
        <span class="phrase"><a name="boost_parser__proposed_.tutorial.the_parse_context._functionname_alt__boost__parser___attr___code__phrase_role__identifier___attr__phrase__phrase_role__special______phrase___code___functionname_"></a></span><a class="link" href="the_parse_context.html#boost_parser__proposed_.tutorial.the_parse_context._functionname_alt__boost__parser___attr___code__phrase_role__identifier___attr__phrase__phrase_role__special______phrase___code___functionname_">_attr()</a>
      </h5>
<p>
        <code class="computeroutput"><a class="link" href="../../boost/parser/_attr.html" title="Function template _attr">_attr()</a></code> returns a reference to the
        value of the current parser's attribute. It is available only when the current
        parser's parse is successful. If the parser has no semantic action, no attribute
        gets added to the parse context. It can be used to read and write the current
        parser's attribute:
      </p>
<pre class="programlisting"><span class="special">[](</span><span class="keyword">auto</span> <span class="special">&amp;</span> <span class="identifier">ctx</span><span class="special">)</span> <span class="special">{</span> <span class="identifier">_attr</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">)</span> <span class="special">=</span> <span class="number">3</span><span class="special">;</span> <span class="special">}</span>
</pre>
<p>
        If the current parser has no attribute, a <code class="computeroutput"><a class="link" href="../../boost/parser/none.html" title="Struct none">none</a></code> is returned.
      </p>
<h5>
<a name="boost_parser__proposed_.tutorial.the_parse_context.h7"></a>
        <span class="phrase"><a name="boost_parser__proposed_.tutorial.the_parse_context._functionname_alt__boost__parser___val___code__phrase_role__identifier___val__phrase__phrase_role__special______phrase___code___functionname_"></a></span><a class="link" href="the_parse_context.html#boost_parser__proposed_.tutorial.the_parse_context._functionname_alt__boost__parser___val___code__phrase_role__identifier___val__phrase__phrase_role__special______phrase___code___functionname_">_val()</a>
      </h5>
<p>
        <code class="computeroutput"><a class="link" href="../../boost/parser/_val.html" title="Function template _val">_val()</a></code> returns a reference to the
        value of the attribute of the current rule being used to parse (if any),
        and is available even before the rule's parse is successful. It can be used
        to set the current rule's attribute, even from a parser that is a subparser
        inside the rule. Let's say we're writing a parser with a semantic action
        that is within a rule. If we want to set the current rule's value to whatever
        this subparser parses, we would write this semantic action:
      </p>
<pre class="programlisting"><span class="special">[](</span><span class="keyword">auto</span> <span class="special">&amp;</span> <span class="identifier">ctx</span><span class="special">)</span> <span class="special">{</span> <span class="identifier">_val</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">)</span> <span class="special">=</span> <span class="identifier">_attr</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">);</span> <span class="special">}</span>
</pre>
<p>
        If there is no current rule, or the current rule has no attribute, a <code class="computeroutput"><a class="link" href="../../boost/parser/none.html" title="Struct none">none</a></code>
        is returned.
      </p>
<h5>
<a name="boost_parser__proposed_.tutorial.the_parse_context.h8"></a>
        <span class="phrase"><a name="boost_parser__proposed_.tutorial.the_parse_context._functionname_alt__boost__parser___globals___code__phrase_role__identifier___globals__phrase__phrase_role__special______phrase___code___functionname_"></a></span><a class="link" href="the_parse_context.html#boost_parser__proposed_.tutorial.the_parse_context._functionname_alt__boost__parser___globals___code__phrase_role__identifier___globals__phrase__phrase_role__special______phrase___code___functionname_">_globals()</a>
      </h5>
<p>
        <code class="computeroutput"><a class="link" href="../../boost/parser/_globals.html" title="Function template _globals">_globals()</a></code> returns a reference to a
        user-supplied struct that contains whatever data you want to use during the
        parse. We'll get into this more later, but for now, here's how you might
        use it:
      </p>
<pre class="programlisting"><span class="special">[](</span><span class="keyword">auto</span> <span class="special">&amp;</span> <span class="identifier">ctx</span><span class="special">)</span> <span class="special">{</span>
    <span class="comment">// black_list is some set of values that are not allowed.</span>
    <span class="keyword">if</span> <span class="special">(</span><span class="identifier">_globals</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">).</span><span class="identifier">black_list</span><span class="special">.</span><span class="identifier">contains</span><span class="special">(</span><span class="identifier">_attr</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">)))</span>
        <span class="identifier">_pass</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">)</span> <span class="special">=</span> <span class="keyword">false</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<h5>
<a name="boost_parser__proposed_.tutorial.the_parse_context.h9"></a>
        <span class="phrase"><a name="boost_parser__proposed_.tutorial.the_parse_context._functionname_alt__boost__parser___locals___code__phrase_role__identifier___locals__phrase__phrase_role__special______phrase___code___functionname_"></a></span><a class="link" href="the_parse_context.html#boost_parser__proposed_.tutorial.the_parse_context._functionname_alt__boost__parser___locals___code__phrase_role__identifier___locals__phrase__phrase_role__special______phrase___code___functionname_">_locals()</a>
      </h5>
<p>
        <code class="computeroutput"><a class="link" href="../../boost/parser/_locals.html" title="Function template _locals">_locals()</a></code> returns a reference to one
        or more values that are local to the current rule being parsed, if any. If
        there are two or more local values, <code class="computeroutput"><a class="link" href="../../boost/parser/_locals.html" title="Function template _locals">_locals()</a></code>
        returns a reference to a <code class="computeroutput"><span class="identifier">hana</span><span class="special">::</span><span class="identifier">tuple</span></code>.
        Rules with locals are something we haven't gotten to yet, but here is how
        you use <code class="computeroutput"><a class="link" href="../../boost/parser/_locals.html" title="Function template _locals">_locals()</a></code>:
      </p>
<pre class="programlisting"><span class="special">[](</span><span class="keyword">auto</span> <span class="special">&amp;</span> <span class="identifier">ctx</span><span class="special">)</span> <span class="special">{</span>
    <span class="keyword">auto</span> <span class="special">&amp;</span> <span class="identifier">local</span> <span class="special">=</span> <span class="identifier">_locals</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">);</span>
    <span class="comment">// Use local here.  If it is a hana::tuple, access its members like this:</span>
    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">hana</span><span class="special">::</span><span class="identifier">literals</span><span class="special">;</span>
    <span class="keyword">auto</span> <span class="special">&amp;</span> <span class="identifier">first_element</span> <span class="special">=</span> <span class="identifier">local</span><span class="special">[</span><span class="number">0</span><span class="identifier">_c</span><span class="special">];</span>
    <span class="keyword">auto</span> <span class="special">&amp;</span> <span class="identifier">second_element</span> <span class="special">=</span> <span class="identifier">local</span><span class="special">[</span><span class="number">1</span><span class="identifier">_c</span><span class="special">];</span>
<span class="special">}</span>
</pre>
<p>
        If there is no current rule, or the current rule has no locals, a <code class="computeroutput"><a class="link" href="../../boost/parser/none.html" title="Struct none">none</a></code>
        is returned.
      </p>
<h5>
<a name="boost_parser__proposed_.tutorial.the_parse_context.h10"></a>
        <span class="phrase"><a name="boost_parser__proposed_.tutorial.the_parse_context._functionname_alt__boost__parser___params___code__phrase_role__identifier___params__phrase__phrase_role__special______phrase___code___functionname_"></a></span><a class="link" href="the_parse_context.html#boost_parser__proposed_.tutorial.the_parse_context._functionname_alt__boost__parser___params___code__phrase_role__identifier___params__phrase__phrase_role__special______phrase___code___functionname_">_params()</a>
      </h5>
<p>
        <code class="computeroutput"><a class="link" href="../../boost/parser/_params.html" title="Function template _params">_params()</a></code>, like <code class="computeroutput"><a class="link" href="../../boost/parser/_locals.html" title="Function template _locals">_locals()</a></code>,
        applies to the current rule being used to parse, if any. It also returns
        a reference to a single value, if the current rule has only one parameter,
        or a <code class="computeroutput"><span class="identifier">hana</span><span class="special">::</span><span class="identifier">tuple</span></code> to multiple values if the current
        rule has multiple parameters.
      </p>
<p>
        If there is no current rule, or the current rule has no parameters, a <code class="computeroutput"><a class="link" href="../../boost/parser/none.html" title="Struct none">none</a></code>
        is returned.
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          <code class="computeroutput"><a class="link" href="../../boost/parser/none.html" title="Struct none">none</a></code>
          is a type that is used as a return value in Boost.Parser for parse context
          accessors. <code class="computeroutput"><a class="link" href="../../boost/parser/none.html" title="Struct none">none</a></code>
          is convertible to anything that has a default constructor, convertible
          from anything, assignable form anything, and has templated overloads for
          all the overloadable operators. The intention is that a misuse of <code class="computeroutput"><a class="link" href="../../boost/parser/_val.html" title="Function template _val">_val()</a></code>, <code class="computeroutput"><a class="link" href="../../boost/parser/_globals.html" title="Function template _globals">_globals()</a></code>,
          etc. should compile, and produce an assertion at runtime. Experience has
          shown that using a debugger for investigating the stack that leads to your
          mistake is a far better user experience than sifting through compiler diagnostics.
          See the <a class="link" href="../rationale.html" title="Rationale">Rationale</a>
          section for a more detailed explanation.
        </p></td></tr>
</table></div>
</div>
<div class="copyright-footer">Copyright © 2020 T. Zachary Laine<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="semantic_actions.html"><img src="../../images/prev.png" alt="Prev"></a><a accesskey="u" href="../tutorial.html"><img src="../../images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../images/home.png" alt="Home"></a><a accesskey="n" href="rule_parsers.html"><img src="../../images/next.png" alt="Next"></a>
</div>
</body>
</html>
