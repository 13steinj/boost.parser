<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>More About Rules</title>
<link rel="stylesheet" href="../../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.79.1">
<link rel="home" href="../../index.html" title="Chapter 1. Boost.Parser (Proposed)">
<link rel="up" href="../tutorial.html" title="Tutorial">
<link rel="prev" href="the__parse____api.html" title="The parse() API">
<link rel="next" href="algorithms_and_views_that_use_parsers.html" title="Algorithms and Views That Use Parsers">
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="spirit-nav">
<a accesskey="p" href="the__parse____api.html"><img src="../../images/prev.png" alt="Prev"></a><a accesskey="u" href="../tutorial.html"><img src="../../images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../images/home.png" alt="Home"></a><a accesskey="n" href="algorithms_and_views_that_use_parsers.html"><img src="../../images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_parser__proposed_.tutorial.more_about_rules"></a><a class="link" href="more_about_rules.html" title="More About Rules">More
      About Rules</a>
</h3></div></div></div>
<p>
        In the earlier page about <code class="computeroutput"><a class="link" href="../../boost/parser/rule.html" title="Struct template rule">rules</a></code> (<a class="link" href="rule_parsers.html" title="Rule Parsers">Rule
        Parsers</a>), I described <code class="computeroutput"><a class="link" href="../../boost/parser/rule.html" title="Struct template rule">rules</a></code> as being analogous to
        functions. <code class="computeroutput"><a class="link" href="../../boost/parser/rule.html" title="Struct template rule">rules</a></code>
        are, at base, organizational. Here are the common use cases for <code class="computeroutput"><a class="link" href="../../boost/parser/rule.html" title="Struct template rule">rules</a></code>.
        Use a <code class="computeroutput"><a class="link" href="../../boost/parser/rule.html" title="Struct template rule">rule</a></code>
        if you want to:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            fix the attribute type produced by a parser to something other than the
            default;
          </li>
<li class="listitem">
            create a parser that produces useful diagnostic text;
          </li>
<li class="listitem">
            create a recursive rule (more on this below);
          </li>
<li class="listitem">
            create a set of mutually-recursive parsers;
          </li>
<li class="listitem">
            separately compile a parser; or
          </li>
<li class="listitem">
            do callback parsing.
          </li>
</ul></div>
<p>
        Let's look at the use cases in detail.
      </p>
<h5>
<a name="boost_parser__proposed_.tutorial.more_about_rules.h0"></a>
        <span class="phrase"><a name="boost_parser__proposed_.tutorial.more_about_rules.fixing_the_attribute_type"></a></span><a class="link" href="more_about_rules.html#boost_parser__proposed_.tutorial.more_about_rules.fixing_the_attribute_type">Fixing
        the attribute type</a>
      </h5>
<p>
        We saw in the previous section how <code class="computeroutput"><a class="link" href="../../boost/parser/parse_idm25858.html" title="Function template parse">parse()</a></code>
        is flexible in what types it will accept as attribute out-parameters.
      </p>
<p>
        That flexibility is a blessing and a curse. For instance, say you wanted
        to use the parser <code class="computeroutput"><span class="special">+</span><a class="link" href="../../boost/parser/char_.html" title="Global char_">char_</a></code> to parse a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code>,
        and capture the result in a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code>.
        <code class="computeroutput"><span class="special">+</span><a class="link" href="../../boost/parser/char_.html" title="Global char_">char_</a></code> generates an
        attribute of <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">&gt;</span></code> when
        parsing a sequence of <code class="computeroutput"><span class="keyword">char</span></code>,
        so you'd have to write the result into a vector first, including all the
        allocations that implies, and then you'd have to allocate space in a string,
        and copy the entire result. Not great. The flexibility of attribute out-parameters
        lets you avoid that. On the other hand, if you want to parse your result
        into a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">&gt;</span></code>,
        but <span class="bold"><strong>accidentally</strong></span> pass a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code>,
        the code is well-formed. Usually, we expect type mismatches like this to
        be ill-formed in C++. Fortunately, <code class="computeroutput"><a class="link" href="../../boost/parser/rule.html" title="Struct template rule">rules</a></code> help you address both
        these concerns.
      </p>
<p>
        First, let's see <code class="computeroutput"><a class="link" href="../../boost/parser/rule.html" title="Struct template rule">rules</a></code>
        used to nail down attribute flexibility. Every rule has a specific attribute
        type. If one is not specified, the rule has no attribute. The fact that the
        attribute is a specific type allows you to remove attribute flexibility.
        For instance, say we have a rule defined like this:
      </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">bp</span><span class="special">::</span><span class="identifier">rule</span><span class="special">&lt;</span><span class="keyword">struct</span> <span class="identifier">doubles</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;&gt;</span> <span class="identifier">doubles</span> <span class="special">=</span> <span class="string">"doubles"</span><span class="special">;</span>
<span class="keyword">auto</span> <span class="keyword">const</span> <span class="identifier">doubles_def</span> <span class="special">=</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">double_</span> <span class="special">%</span> <span class="char">','</span><span class="special">;</span>
<span class="identifier">BOOST_PARSER_DEFINE_RULES</span><span class="special">(</span><span class="identifier">doubles</span><span class="special">);</span>
</pre>
<p>
      </p>
<p>
        You can then use it in a call to <code class="computeroutput"><a class="link" href="../../boost/parser/parse_idm25858.html" title="Function template parse">parse()</a></code>,
        and <code class="computeroutput"><a class="link" href="../../boost/parser/parse_idm25858.html" title="Function template parse">parse()</a></code> will return a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">optional</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;&gt;</span></code>:
      </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">auto</span> <span class="keyword">const</span> <span class="identifier">result</span> <span class="special">=</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">parse</span><span class="special">(</span><span class="identifier">input</span><span class="special">,</span> <span class="identifier">doubles</span><span class="special">,</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">ws</span><span class="special">);</span>
</pre>
<p>
      </p>
<p>
        If you call <code class="computeroutput"><a class="link" href="../../boost/parser/parse_idm25858.html" title="Function template parse">parse()</a></code> with an attribute out-parameter,
        it must be exactly <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;</span></code>:
      </p>
<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;</span> <span class="identifier">vec_result</span><span class="special">;</span>
<span class="identifier">bp</span><span class="special">::</span><span class="identifier">parse</span><span class="special">(</span><span class="identifier">input</span><span class="special">,</span> <span class="identifier">doubles</span><span class="special">,</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">ws</span><span class="special">,</span> <span class="identifier">vec_result</span><span class="special">);</span> <span class="comment">// Ok.</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">deque</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;</span> <span class="identifier">deque_result</span><span class="special">;</span>
<span class="identifier">bp</span><span class="special">::</span><span class="identifier">parse</span><span class="special">(</span><span class="identifier">input</span><span class="special">,</span> <span class="identifier">doubles</span><span class="special">,</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">ws</span><span class="special">,</span> <span class="identifier">deque_result</span><span class="special">);</span> <span class="comment">// Ill-formed!</span>
</pre>
<p>
        If we wanted to use a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">deque</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;</span></code> as the attribute type of our rule:
      </p>
<pre class="programlisting"><span class="comment">// Attribute changed to std::deque&lt;double&gt;.</span>
<span class="identifier">bp</span><span class="special">::</span><span class="identifier">rule</span><span class="special">&lt;</span><span class="keyword">struct</span> <span class="identifier">doubles</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">deque</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;&gt;</span> <span class="identifier">doubles</span> <span class="special">=</span> <span class="string">"doubles"</span><span class="special">;</span>
<span class="keyword">auto</span> <span class="keyword">const</span> <span class="identifier">doubles_def</span> <span class="special">=</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">double_</span> <span class="special">%</span> <span class="char">','</span><span class="special">;</span>
<span class="identifier">BOOST_PARSER_DEFINE_RULES</span><span class="special">(</span><span class="identifier">doubles</span><span class="special">);</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">deque</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;</span> <span class="identifier">deque_result</span><span class="special">;</span>
    <span class="identifier">bp</span><span class="special">::</span><span class="identifier">parse</span><span class="special">(</span><span class="identifier">input</span><span class="special">,</span> <span class="identifier">doubles</span><span class="special">,</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">ws</span><span class="special">,</span> <span class="identifier">deque_result</span><span class="special">);</span> <span class="comment">// Ok.</span>
<span class="special">}</span>
</pre>
<p>
        So, the attribute flexibility is still available, but only <span class="bold"><strong>within</strong></span>
        the rule — the parser <code class="computeroutput"><span class="identifier">bp</span><span class="special">::</span><span class="identifier">double_</span> <span class="special">%</span> <span class="char">','</span></code> can parse
        into a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;</span></code>
        or a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">deque</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;</span></code>,
        but the rule <code class="computeroutput"><span class="identifier">doubles</span></code> must
        parse into only the exact attribute it was declared to generate.
      </p>
<p>
        The reason for this is that, inside the rule parsing implementation, there
        is code something like this:
      </p>
<pre class="programlisting"><span class="keyword">using</span> <span class="identifier">attr_t</span> <span class="special">=</span> <span class="emphasis"><em><code class="literal">ATTR</code></em></span><span class="special">(</span><span class="identifier">doubles_def</span><span class="special">);</span>
<span class="identifier">attr_t</span> <span class="identifier">attr</span><span class="special">;</span>
<span class="identifier">parse</span><span class="special">(</span><span class="identifier">first</span><span class="special">,</span> <span class="identifier">last</span><span class="special">,</span> <span class="identifier">parser</span><span class="special">,</span> <span class="identifier">attr</span><span class="special">);</span>
<span class="identifier">attribute_out_param</span> <span class="special">=</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span><span class="identifier">attr</span><span class="special">);</span>
</pre>
<p>
        Where <code class="computeroutput"><span class="identifier">attribute_out_param</span></code>
        is the attribute out-parameter we pass to <code class="computeroutput"><a class="link" href="../../boost/parser/parse_idm25858.html" title="Function template parse">parse()</a></code>.
        If that final move assignment is ill-formed, the call to <code class="computeroutput"><a class="link" href="../../boost/parser/parse_idm25858.html" title="Function template parse">parse()</a></code>
        is too.
      </p>
<p>
        You can also use rules to exploit attribute flexibility. Even though a rule
        reduces the flexibility of attributes it can generate, the fact that it is
        so easy to write a new rule means that we can use rules themselves to get
        the attribute flexibility we want across our code:
      </p>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">bp</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">parser</span><span class="special">;</span>

<span class="comment">// We only need to write the definition once...</span>
<span class="keyword">auto</span> <span class="keyword">const</span> <span class="identifier">generic_doubles_def</span> <span class="special">=</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">double_</span> <span class="special">%</span> <span class="char">','</span><span class="special">;</span>

<span class="identifier">bp</span><span class="special">::</span><span class="identifier">rule</span><span class="special">&lt;</span><span class="keyword">struct</span> <span class="identifier">vec_doubles</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;&gt;</span> <span class="identifier">vec_doubles</span> <span class="special">=</span> <span class="string">"vec_doubles"</span><span class="special">;</span>
<span class="keyword">auto</span> <span class="keyword">const</span> <span class="special">&amp;</span> <span class="identifier">vec_doubles_def</span> <span class="special">=</span> <span class="identifier">generic_doubles_def</span><span class="special">;</span> <span class="comment">// ... and re-use it,</span>
<span class="identifier">BOOST_PARSER_DEFINE_RULES</span><span class="special">(</span><span class="identifier">vec_doubles</span><span class="special">);</span>

<span class="comment">// Attribute changed to std::deque&lt;double&gt;.</span>
<span class="identifier">bp</span><span class="special">::</span><span class="identifier">rule</span><span class="special">&lt;</span><span class="keyword">struct</span> <span class="identifier">deque_doubles</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">deque</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;&gt;</span> <span class="identifier">deque_doubles</span> <span class="special">=</span> <span class="string">"deque_doubles"</span><span class="special">;</span>
<span class="keyword">auto</span> <span class="keyword">const</span> <span class="special">&amp;</span> <span class="identifier">deque_doubles_def</span> <span class="special">=</span> <span class="identifier">generic_doubles_def</span><span class="special">;</span> <span class="comment">// ... and re-use it again.</span>
<span class="identifier">BOOST_PARSER_DEFINE_RULES</span><span class="special">(</span><span class="identifier">deque_doubles</span><span class="special">);</span>
</pre>
<p>
        Now we have one of each, and we did not have to copy any parsing logic that
        would have to be maintained in two places.
      </p>
<h5>
<a name="boost_parser__proposed_.tutorial.more_about_rules.h1"></a>
        <span class="phrase"><a name="boost_parser__proposed_.tutorial.more_about_rules.creating_a_parser_for_better_diagnostics"></a></span><a class="link" href="more_about_rules.html#boost_parser__proposed_.tutorial.more_about_rules.creating_a_parser_for_better_diagnostics">Creating
        a parser for better diagnostics</a>
      </h5>
<p>
        Each <code class="computeroutput"><a class="link" href="../../boost/parser/rule.html" title="Struct template rule">rule</a></code>
        has associated diagnostic text that Boost.Parser can use for failures of
        that rule. This is useful when the parse reaches a parse failure at an expectation
        point (see <a class="link" href="../../">Expectation
        points</a>). Let's say you have the following code defined somewhere.
      </p>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">bp</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">parser</span><span class="special">;</span>

<span class="identifier">bp</span><span class="special">::</span><span class="identifier">rule</span><span class="special">&lt;</span><span class="keyword">struct</span> <span class="identifier">value_tag</span><span class="special">&gt;</span> <span class="identifier">value</span> <span class="special">=</span>
    <span class="string">"an integer, or a list of integers in braces"</span><span class="special">;</span>

<span class="keyword">auto</span> <span class="keyword">const</span> <span class="identifier">ints</span> <span class="special">=</span> <span class="char">'{'</span> <span class="special">&gt;</span> <span class="special">(</span><span class="identifier">value</span> <span class="special">%</span> <span class="char">','</span><span class="special">)</span> <span class="special">&gt;</span> <span class="char">'}'</span><span class="special">;</span>
<span class="keyword">auto</span> <span class="keyword">const</span> <span class="identifier">value_def</span> <span class="special">=</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">int_</span> <span class="special">|</span> <span class="identifier">ints</span><span class="special">;</span>

<span class="identifier">BOOST_PARSER_DEFINE_RULES</span><span class="special">(</span><span class="identifier">value</span><span class="special">);</span>
</pre>
<p>
        Notice the two expectation points. One before <code class="computeroutput"><span class="special">(</span><span class="identifier">value</span> <span class="special">%</span> <span class="char">','</span><span class="special">)</span></code>, one before
        the final <code class="computeroutput"><span class="char">'}'</span></code>. Later, you call
        parse in some input:
      </p>
<pre class="programlisting"><span class="identifier">bp</span><span class="special">::</span><span class="identifier">parse</span><span class="special">(</span><span class="string">"{ 4, 5 a"</span><span class="special">,</span> <span class="identifier">value</span><span class="special">,</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">ws</span><span class="special">);</span>
</pre>
<p>
        This runs should of the second expectation point, and produces output like
        this:
      </p>
<pre class="programlisting">1:7: error: Expected '}' here:
{ 4, 5 a
       ^
</pre>
<p>
        That's a pretty good error message. Here's what it looks like if we violate
        the earlier expectation:
      </p>
<pre class="programlisting"><span class="identifier">bp</span><span class="special">::</span><span class="identifier">parse</span><span class="special">(</span><span class="string">"{ }"</span><span class="special">,</span> <span class="identifier">value</span><span class="special">,</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">ws</span><span class="special">);</span>
</pre>
<pre class="programlisting">1:2: error: Expected an integer, or a list of integers in braces % ',' here:
{ }
  ^
</pre>
<p>
        Not nearly as nice. The problem is that the expectation is on <code class="computeroutput"><span class="special">(</span><span class="identifier">value</span> <span class="special">%</span> <span class="char">','</span><span class="special">)</span></code>.
        So, even thought we gave <code class="computeroutput"><span class="identifier">value</span></code>
        reasonable dianostic text, we put the text on the wrong thing. We can introduce
        a new rule to put the diagnstic text in the right place.
      </p>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">bp</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">parser</span><span class="special">;</span>

<span class="identifier">bp</span><span class="special">::</span><span class="identifier">rule</span><span class="special">&lt;</span><span class="keyword">struct</span> <span class="identifier">value_tag</span><span class="special">&gt;</span> <span class="identifier">value</span> <span class="special">=</span>
    <span class="string">"an integer, or a list of integers in braces"</span><span class="special">;</span>
<span class="identifier">bp</span><span class="special">::</span><span class="identifier">rule</span><span class="special">&lt;</span><span class="keyword">struct</span> <span class="identifier">comma_values_tag</span><span class="special">&gt;</span> <span class="identifier">comma_values</span> <span class="special">=</span>
    <span class="string">"a comma-delimited list of integers"</span><span class="special">;</span>

<span class="keyword">auto</span> <span class="keyword">const</span> <span class="identifier">ints</span> <span class="special">=</span> <span class="char">'{'</span> <span class="special">&gt;</span> <span class="identifier">comma_values</span> <span class="special">&gt;</span> <span class="char">'}'</span><span class="special">;</span>
<span class="keyword">auto</span> <span class="keyword">const</span> <span class="identifier">value_def</span> <span class="special">=</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">int_</span> <span class="special">|</span> <span class="identifier">ints</span><span class="special">;</span>
<span class="keyword">auto</span> <span class="keyword">const</span> <span class="identifier">comma_values_def</span> <span class="special">=</span> <span class="special">(</span><span class="identifier">value</span> <span class="special">%</span> <span class="char">','</span><span class="special">);</span>

<span class="identifier">BOOST_PARSER_DEFINE_RULES</span><span class="special">(</span><span class="identifier">value</span><span class="special">,</span> <span class="identifier">comma_values</span><span class="special">);</span>
</pre>
<p>
        Now when we call <code class="computeroutput"><span class="identifier">bp</span><span class="special">::</span><span class="identifier">parse</span><span class="special">(</span><span class="string">"{ }"</span><span class="special">,</span>
        <span class="identifier">value</span><span class="special">,</span>
        <span class="identifier">bp</span><span class="special">::</span><span class="identifier">ws</span><span class="special">)</span></code> we
        get a much better message:
      </p>
<pre class="programlisting">1:2: error: Expected a comma-delimited list of integers here:
{ }
  ^
</pre>
<p>
        The <code class="computeroutput"><a class="link" href="../../boost/parser/rule.html" title="Struct template rule">rule</a></code>
        <code class="computeroutput"><span class="identifier">value</span></code> might be useful elsewhere
        in our code, perhaps in another parser. It's diagnostic text is appropriate
        for those other potential uses.
      </p>
<h5>
<a name="boost_parser__proposed_.tutorial.more_about_rules.h2"></a>
        <span class="phrase"><a name="boost_parser__proposed_.tutorial.more_about_rules.recursive_rules"></a></span><a class="link" href="more_about_rules.html#boost_parser__proposed_.tutorial.more_about_rules.recursive_rules">Recursive
        rules</a>
      </h5>
<p>
        It's pretty common to see grammars that include recursive rules. Consider
        this EBNF rule for balanced parentheses:
      </p>
<pre class="programlisting">&lt;parens&gt; ::= "" | ( "(" &lt;parens&gt; ")" )
</pre>
<p>
        We can try to write this using Boost.Parser like this:
      </p>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">bp</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">parser</span><span class="special">;</span>
<span class="keyword">auto</span> <span class="keyword">const</span> <span class="identifier">parens</span> <span class="special">=</span> <span class="char">'('</span> <span class="special">&gt;&gt;</span> <span class="identifier">parens</span> <span class="special">&gt;&gt;</span> <span class="char">')'</span> <span class="special">|</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">eps</span><span class="special">;</span>
</pre>
<p>
        We had to put the <code class="computeroutput"><span class="identifier">bp</span><span class="special">::</span><span class="identifier">eps</span></code> second, because Boost.Parser's parsing
        algorithm is greedy. Otherwise, it's just a straight transliteration. Unfortunately,
        it does not work. The code is ill-formed because you can't define a variable
        in terms of itself. Well you can, but nothing good comes of it. If we instead
        make the parser in terms of a forward-declared <code class="computeroutput"><a class="link" href="../../boost/parser/rule.html" title="Struct template rule">rule</a></code>, it works.
      </p>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">bp</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">parser</span><span class="special">;</span>
<span class="identifier">bp</span><span class="special">::</span><span class="identifier">rule</span><span class="special">&lt;</span><span class="keyword">struct</span> <span class="identifier">parens_tag</span><span class="special">&gt;</span> <span class="identifier">parens</span> <span class="special">=</span> <span class="string">"matched parentheses"</span><span class="special">;</span>
<span class="keyword">auto</span> <span class="keyword">const</span> <span class="identifier">parens_def</span> <span class="special">=</span> <span class="char">'('</span> <span class="special">&gt;&gt;</span> <span class="identifier">parens</span> <span class="special">&gt;</span> <span class="char">')'</span> <span class="special">|</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">eps</span><span class="special">;</span>
<span class="identifier">BOOST_PARSER_DEFINE_RULES</span><span class="special">(</span><span class="identifier">parens</span><span class="special">);</span>
</pre>
<p>
        Later, if we use it to parse, it does what we want.
      </p>
<pre class="programlisting"><span class="identifier">assert</span><span class="special">(</span><span class="identifier">bp</span><span class="special">::</span><span class="identifier">parse</span><span class="special">(</span><span class="string">"(((())))"</span><span class="special">,</span> <span class="identifier">parens</span><span class="special">,</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">ws</span><span class="special">));</span>
</pre>
<p>
        When it fails, it even produces nice diagnostics.
      </p>
<pre class="programlisting"><span class="identifier">bp</span><span class="special">::</span><span class="identifier">parse</span><span class="special">(</span><span class="string">"(((()))"</span><span class="special">,</span> <span class="identifier">parens</span><span class="special">,</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">ws</span><span class="special">);</span>
</pre>
<pre class="programlisting">1:7: error: Expected ')' here (end of input):
(((()))
       ^
</pre>
<p>
        Recursive <code class="computeroutput"><a class="link" href="../../boost/parser/rule.html" title="Struct template rule">rules</a></code>
        work differently from other parsers in one way: when re-entering the rule
        recursively, only the attribute variable (<code class="computeroutput"><span class="identifier">_attr</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">)</span></code>
        in your semantic actions) is unique to that instance of the rule. All the
        other state of the uppermost instance of that rule is shared. This includes
        the value of the rule (<code class="computeroutput"><span class="identifier">_val</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">)</span></code>),
        and the locals and parameters to the rule. In other words, <code class="computeroutput"><span class="identifier">_val</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">)</span></code> returns a reference to the <span class="bold"><strong>same
        object</strong></span> in every instance of a recursive <code class="computeroutput"><a class="link" href="../../boost/parser/rule.html" title="Struct template rule">rule</a></code>. This is because each
        instance of the rule needs a place to put the attribute it generates from
        its parse. However, we only want a single return value for the uppermost
        rule; if each instance had a separate value in <code class="computeroutput"><span class="identifier">_val</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">)</span></code>,
        then it would be impossible to build up the result of a recursive rule step
        by step during in the evaluation of the recursive instantiations.
      </p>
<p>
        Also, consider this rule:
      </p>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">bp</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">parser</span><span class="special">;</span>
<span class="identifier">bp</span><span class="special">::</span><span class="identifier">rule</span><span class="special">&lt;</span><span class="keyword">struct</span> <span class="identifier">ints_tag</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;&gt;</span> <span class="identifier">ints</span> <span class="special">=</span> <span class="string">"ints"</span><span class="special">;</span>
<span class="keyword">auto</span> <span class="keyword">const</span> <span class="identifier">ints_def</span> <span class="special">=</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">int_</span> <span class="special">&gt;&gt;</span> <span class="identifier">ints</span> <span class="special">|</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">eps</span><span class="special">;</span>
</pre>
<p>
        What is the default attribute type for ints_def? It sure looks like <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">optional</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;&gt;</span></code>.
        Inside the evaluation of <code class="computeroutput"><span class="identifier">ints</span></code>,
        Boost.Parser must evaluate <code class="computeroutput"><span class="identifier">ints_def</span></code>,
        and then produce a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span></code> —
        the return type of <code class="computeroutput"><span class="identifier">ints</span></code> —
        from it. How? How do you turn a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">optional</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;&gt;</span></code>
        into a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span></code>? To
        a human, it seems obvious, but the metaprogramming that properly handles
        this simple example and the general case is certainly beyond me.
      </p>
<p>
        Boost.Parser has a specific semantic for what consitutes a recursive rule.
        Each rule has a tag type associated with it, and if Boost.Parser enters a
        rule with a certain tag <code class="computeroutput"><span class="identifier">Tag</span></code>,
        and the currently-evaluating rule (if there is one) also has the tag <code class="computeroutput"><span class="identifier">Tag</span></code>, then rule instance being entered is
        considered to be a recursion. No other situations are considered recursion.
        In particular, if you have rules <code class="computeroutput"><span class="identifier">Ra</span></code>
        and <code class="computeroutput"><span class="identifier">Rb</span></code>, and <code class="computeroutput"><span class="identifier">Ra</span></code> uses <code class="computeroutput"><span class="identifier">Rb</span></code>,
        which in turn used <code class="computeroutput"><span class="identifier">Ra</span></code>, the
        second use of <code class="computeroutput"><span class="identifier">Ra</span></code> is not considered
        recursion. <code class="computeroutput"><span class="identifier">Ra</span></code> and <code class="computeroutput"><span class="identifier">Rb</span></code> are of course mutually recursive, but
        neither is considered a "recursive rule" for purposes of getting
        a unique value, locals, and parameters.
      </p>
<h5>
<a name="boost_parser__proposed_.tutorial.more_about_rules.h3"></a>
        <span class="phrase"><a name="boost_parser__proposed_.tutorial.more_about_rules.mutually_recursive_rules"></a></span><a class="link" href="more_about_rules.html#boost_parser__proposed_.tutorial.more_about_rules.mutually_recursive_rules">Mutually-recursive
        rules</a>
      </h5>
<p>
        One of the advantages of using rules is that you can declare all your rules
        up front and then use them immediately afterward. This lets you make rules
        that use each other without introducing cycles:
      </p>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">bp</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">parser</span><span class="special">;</span>

<span class="comment">// Assume we have some polymorphic type that can be an object/dictionary,</span>
<span class="comment">// array, string, or int, called `value_type`.</span>

<span class="identifier">bp</span><span class="special">::</span><span class="identifier">rule</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">string</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&gt;</span> <span class="keyword">const</span> <span class="identifier">string</span> <span class="special">=</span> <span class="string">"string"</span><span class="special">;</span>
<span class="identifier">bp</span><span class="special">::</span><span class="identifier">rule</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">object_element</span><span class="special">,</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">tuple</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span> <span class="identifier">value_type</span><span class="special">&gt;&gt;</span> <span class="keyword">const</span> <span class="identifier">object_element</span> <span class="special">=</span> <span class="string">"object-element"</span><span class="special">;</span>
<span class="identifier">bp</span><span class="special">::</span><span class="identifier">rule</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">object</span><span class="special">,</span> <span class="identifier">value_type</span><span class="special">&gt;</span> <span class="keyword">const</span> <span class="identifier">object</span> <span class="special">=</span> <span class="string">"object"</span><span class="special">;</span>
<span class="identifier">bp</span><span class="special">::</span><span class="identifier">rule</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">array</span><span class="special">,</span> <span class="identifier">value_type</span><span class="special">&gt;</span> <span class="keyword">const</span> <span class="identifier">array</span> <span class="special">=</span> <span class="string">"array"</span><span class="special">;</span>
<span class="identifier">bp</span><span class="special">::</span><span class="identifier">rule</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">value_tag</span><span class="special">,</span> <span class="identifier">value_type</span><span class="special">&gt;</span> <span class="keyword">const</span> <span class="identifier">value</span> <span class="special">=</span> <span class="string">"value"</span><span class="special">;</span>

<span class="keyword">auto</span> <span class="keyword">const</span> <span class="identifier">string_def</span> <span class="special">=</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">lexeme</span><span class="special">[</span><span class="char">'"'</span> <span class="special">&gt;&gt;</span> <span class="special">*(</span><span class="identifier">bp</span><span class="special">::</span><span class="identifier">char_</span> <span class="special">-</span> <span class="char">'"'</span><span class="special">)</span> <span class="special">&gt;</span> <span class="char">'"'</span><span class="special">];</span>
<span class="keyword">auto</span> <span class="keyword">const</span> <span class="identifier">object_element_def</span> <span class="special">=</span> <span class="identifier">string</span> <span class="special">&gt;</span> <span class="char">':'</span> <span class="special">&gt;</span> <span class="identifier">value</span><span class="special">;</span>
<span class="keyword">auto</span> <span class="keyword">const</span> <span class="identifier">object_def</span> <span class="special">=</span> <span class="char">'{'</span><span class="identifier">_l</span> <span class="special">&gt;&gt;</span> <span class="special">-(</span><span class="identifier">object_element</span> <span class="special">%</span> <span class="char">','</span><span class="special">)</span> <span class="special">&gt;</span> <span class="char">'}'</span><span class="special">;</span>
<span class="keyword">auto</span> <span class="keyword">const</span> <span class="identifier">array_def</span> <span class="special">=</span> <span class="char">'['</span><span class="identifier">_l</span> <span class="special">&gt;&gt;</span> <span class="special">-(</span><span class="identifier">value</span> <span class="special">%</span> <span class="char">','</span><span class="special">)</span> <span class="special">&gt;</span> <span class="char">']'</span><span class="special">;</span>
<span class="keyword">auto</span> <span class="keyword">const</span> <span class="identifier">value_def</span> <span class="special">=</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">int_</span> <span class="special">|</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">bool_</span> <span class="special">|</span> <span class="identifier">string</span> <span class="special">|</span> <span class="identifier">array</span> <span class="special">|</span> <span class="identifier">object</span><span class="special">;</span>

<span class="identifier">BOOST_PARSER_DEFINE_RULES</span><span class="special">(</span><span class="identifier">string</span><span class="special">,</span> <span class="identifier">object_element</span><span class="special">,</span> <span class="identifier">object</span><span class="special">,</span> <span class="identifier">array</span><span class="special">,</span> <span class="identifier">value</span><span class="special">);</span>
</pre>
<p>
        Here we have a parser for a Javascript-value-like type <code class="computeroutput"><span class="identifier">value_type</span></code>.
        <code class="computeroutput"><span class="identifier">value_type</span></code> may be an array,
        which itself may contain other arrays, objects, strings, etc. Since we need
        to be able to parse objects within arrays and vice versa, we need each of
        those two parsers to be able to refer to each other.
      </p>
<h5>
<a name="boost_parser__proposed_.tutorial.more_about_rules.h4"></a>
        <span class="phrase"><a name="boost_parser__proposed_.tutorial.more_about_rules.separately_compiled_rules"></a></span><a class="link" href="more_about_rules.html#boost_parser__proposed_.tutorial.more_about_rules.separately_compiled_rules">Separately
        compiled rules</a>
      </h5>
<p>
        Boost.Parser is obviously very template-heavy. However, the template parameters
        used in your in Boost.Parser code are all known at the time you write your
        rules and parsers — except for the range you're parsing.
      </p>
<p>
        Therefore, if you know you're only going to parse with a single kind of range,
        you can declare a function that does the parsing, and put the implementation
        in a .cpp file. I know. A Boost author talking about putting code in non-header
        files is weird. Let's see an example; first, we forward declare our parse
        function in a header.
      </p>
<pre class="programlisting"><span class="comment">// foo.h</span>
<span class="keyword">bool</span> <span class="identifier">balanced_parens</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string_view</span> <span class="identifier">str</span><span class="special">);</span>
</pre>
<p>
        Then we define the function, plus all the rules and parsers it uses, in an
        implementation file:
      </p>
<pre class="programlisting"><span class="comment">// foo.cpp</span>
<span class="keyword">namespace</span> <span class="special">{</span>
    <span class="keyword">namespace</span> <span class="identifier">bp</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">parser</span><span class="special">;</span>
    <span class="identifier">bp</span><span class="special">::</span><span class="identifier">rule</span><span class="special">&lt;</span><span class="keyword">struct</span> <span class="identifier">parens_tag</span><span class="special">&gt;</span> <span class="identifier">parens</span> <span class="special">=</span> <span class="string">"matched parentheses"</span><span class="special">;</span>
    <span class="keyword">auto</span> <span class="keyword">const</span> <span class="identifier">parens_def</span> <span class="special">=</span> <span class="special">(</span><span class="char">'('</span> <span class="special">&gt;&gt;</span> <span class="identifier">parens</span> <span class="special">&gt;</span> <span class="char">')'</span><span class="special">)</span> <span class="special">|</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">eps</span><span class="special">;</span>
    <span class="identifier">BOOST_PARSER_DEFINE_RULES</span><span class="special">(</span><span class="identifier">parens</span><span class="special">);</span>
<span class="special">}</span>
<span class="keyword">bool</span> <span class="identifier">balanced_parens</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string_view</span> <span class="identifier">str</span><span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">namespace</span> <span class="identifier">bp</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">parser</span><span class="special">;</span>
    <span class="keyword">return</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">parse</span><span class="special">(</span><span class="identifier">str</span><span class="special">,</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">omit</span><span class="special">[</span><span class="identifier">parens</span><span class="special">],</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">ws</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
        For large parsers, separate compilation can be a significant savings on build
        time.
      </p>
<h5>
<a name="boost_parser__proposed_.tutorial.more_about_rules.h5"></a>
        <span class="phrase"><a name="boost_parser__proposed_.tutorial.more_about_rules.callback_parsing"></a></span><a class="link" href="more_about_rules.html#boost_parser__proposed_.tutorial.more_about_rules.callback_parsing">Callback
        parsing</a>
      </h5>
<p>
        Only <code class="computeroutput"><a class="link" href="../../boost/parser/rule.html" title="Struct template rule">rules</a></code>
        can be callback parsers, so if you want to get attributes supplied to you
        via callbacks instead of somewhere in the middle of a giant attribute that
        represents the whole parse result, you need to use <code class="computeroutput"><a class="link" href="../../boost/parser/rule.html" title="Struct template rule">rules</a></code>. See <a class="link" href="../extended_examples/parsing_json_with_callbacks.html" title="Parsing JSON With Callbacks">Parsing
        JSON With Callbacks</a> for an extended example of callback parsing.
      </p>
<h5>
<a name="boost_parser__proposed_.tutorial.more_about_rules.h6"></a>
        <span class="phrase"><a name="boost_parser__proposed_.tutorial.more_about_rules.accessors_available_in_semantic_actions_on_rules"></a></span><a class="link" href="more_about_rules.html#boost_parser__proposed_.tutorial.more_about_rules.accessors_available_in_semantic_actions_on_rules">Accessors
        available in semantic actions on rules</a>
      </h5>
<h5>
<a name="boost_parser__proposed_.tutorial.more_about_rules.h7"></a>
        <span class="phrase"><a name="boost_parser__proposed_.tutorial.more_about_rules._functionname_alt__boost__parser___val___code__phrase_role__identifier___val__phrase__phrase_role__special______phrase___code___functionname_"></a></span><a class="link" href="more_about_rules.html#boost_parser__proposed_.tutorial.more_about_rules._functionname_alt__boost__parser___val___code__phrase_role__identifier___val__phrase__phrase_role__special______phrase___code___functionname_">_val()</a>
      </h5>
<p>
        Inside all of a rule's semantic actions, the expression <code class="computeroutput"><a class="link" href="../../boost/parser/_val.html" title="Function template _val">_val</a><span class="special">(</span><span class="identifier">ctx</span><span class="special">)</span></code>
        is a reference to the attribute that the rule generates. This can be useful
        when you want subparsers to build up the attribute in a specific way:
      </p>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">bp</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">parser</span><span class="special">;</span>
<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">literals</span><span class="special">;</span>

<span class="identifier">bp</span><span class="special">::</span><span class="identifier">rule</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">ints</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;&gt;</span> <span class="keyword">const</span> <span class="identifier">ints</span> <span class="special">=</span> <span class="string">"ints"</span><span class="special">;</span>
<span class="keyword">auto</span> <span class="identifier">twenty_zeros</span> <span class="special">=</span> <span class="special">[](</span><span class="keyword">auto</span> <span class="special">&amp;</span> <span class="identifier">ctx</span><span class="special">)</span> <span class="special">{</span> <span class="identifier">_val</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">).</span><span class="identifier">resize</span><span class="special">(</span><span class="number">20</span><span class="special">,</span> <span class="number">0</span><span class="special">);</span> <span class="special">};</span>
<span class="keyword">auto</span> <span class="identifier">push_back</span> <span class="special">=</span> <span class="special">[](</span><span class="keyword">auto</span> <span class="special">&amp;</span> <span class="identifier">ctx</span><span class="special">)</span> <span class="special">{</span> <span class="identifier">_val</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">).</span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">_attr</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">));</span> <span class="special">};</span>
<span class="keyword">auto</span> <span class="keyword">const</span> <span class="identifier">ints_def</span> <span class="special">=</span> <span class="string">"20-zeros"</span><span class="identifier">_l</span><span class="special">[</span><span class="identifier">twenty_zeros</span><span class="special">]</span> <span class="special">|</span> <span class="special">+</span><span class="identifier">bp</span><span class="special">::</span><span class="identifier">int_</span><span class="special">[</span><span class="identifier">push_back</span><span class="special">];</span>
<span class="identifier">BOOST_PARSER_DEFINE_RULES</span><span class="special">(</span><span class="identifier">ints</span><span class="special">);</span>
</pre>
<div class="tip"><table border="0" summary="Tip">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="../../images/tip.png"></td>
<th align="left">Tip</th>
</tr>
<tr><td align="left" valign="top"><p>
          That's just an example. It's almost always better to do things without
          using semantic actions. We could have instead written <code class="computeroutput"><span class="identifier">ints_def</span></code>
          as <code class="computeroutput"><span class="string">"20-zeros"</span> <span class="special">&gt;&gt;</span>
          <span class="identifier">bp</span><span class="special">::</span><span class="identifier">attr</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;(</span><span class="number">20</span><span class="special">))</span> <span class="special">|</span>
          <span class="special">+</span><span class="identifier">bp</span><span class="special">::</span><span class="identifier">int_</span></code>,
          which has the same semantics, is a lot easier to read, and is a lot less
          code.
        </p></td></tr>
</table></div>
<h5>
<a name="boost_parser__proposed_.tutorial.more_about_rules.h8"></a>
        <span class="phrase"><a name="boost_parser__proposed_.tutorial.more_about_rules.locals"></a></span><a class="link" href="more_about_rules.html#boost_parser__proposed_.tutorial.more_about_rules.locals">Locals</a>
      </h5>
<p>
        The <code class="computeroutput"><a class="link" href="../../boost/parser/rule.html" title="Struct template rule">rule</a></code>
        template takes another template parameter we have not discussed yet. You
        can pass a third parameter to <code class="computeroutput"><a class="link" href="../../boost/parser/rule.html" title="Struct template rule">rule</a></code>, which will be available
        within semantic actions used in the rule as <code class="computeroutput"><a class="link" href="../../boost/parser/_locals.html" title="Function template _locals">_locals</a><span class="special">(</span><span class="identifier">ctx</span><span class="special">)</span></code>. This
        gives your rule some local state, if it needs it:
      </p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">foo_locals</span>
<span class="special">{</span>
    <span class="keyword">char</span> <span class="identifier">first_value</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span>
<span class="special">};</span>

<span class="keyword">namespace</span> <span class="identifier">bp</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">parser</span><span class="special">;</span>

<span class="identifier">bp</span><span class="special">::</span><span class="identifier">rule</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">foo</span><span class="special">,</span> <span class="keyword">int</span><span class="special">,</span> <span class="identifier">foo_locals</span><span class="special">&gt;</span> <span class="keyword">const</span> <span class="identifier">foo</span> <span class="special">=</span> <span class="string">"foo"</span><span class="special">;</span>

<span class="keyword">auto</span> <span class="identifier">record_first</span> <span class="special">=</span> <span class="special">[](</span><span class="keyword">auto</span> <span class="special">&amp;</span> <span class="identifier">ctx</span><span class="special">)</span> <span class="special">{</span> <span class="identifier">_locals</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">).</span><span class="identifier">first_value</span> <span class="special">=</span> <span class="identifier">_attr</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">);</span> <span class="special">}</span>
<span class="keyword">auto</span> <span class="identifier">check_against_first</span> <span class="special">=</span> <span class="special">[](</span><span class="keyword">auto</span> <span class="special">&amp;</span> <span class="identifier">ctx</span><span class="special">)</span> <span class="special">{</span>
    <span class="keyword">char</span> <span class="keyword">const</span> <span class="identifier">first</span> <span class="special">=</span> <span class="identifier">_locals</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">).</span><span class="identifier">first_value</span><span class="special">;</span>
    <span class="keyword">char</span> <span class="keyword">const</span> <span class="identifier">attr</span> <span class="special">=</span> <span class="identifier">_attr</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">);</span>
    <span class="keyword">if</span> <span class="special">(</span><span class="identifier">attr</span> <span class="special">==</span> <span class="identifier">first</span><span class="special">)</span>
        <span class="identifier">_pass</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">)</span> <span class="special">=</span> <span class="keyword">false</span><span class="special">;</span>
    <span class="identifier">_val</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">)</span> <span class="special">=</span> <span class="special">(</span><span class="keyword">int</span><span class="special">(</span><span class="identifier">first</span><span class="special">)</span> <span class="special">&lt;&lt;</span> <span class="number">8</span><span class="special">)</span> <span class="special">|</span> <span class="keyword">int</span><span class="special">(</span><span class="identifier">attr</span><span class="special">);</span>
<span class="special">};</span>

<span class="keyword">auto</span> <span class="keyword">const</span> <span class="identifier">foo_def</span> <span class="special">=</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">cu</span><span class="special">[</span><span class="identifier">record_first</span><span class="special">]</span> <span class="special">&gt;&gt;</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">cu</span><span class="special">[</span><span class="identifier">check_against_first</span><span class="special">];</span>
<span class="identifier">BOOST_PARSER_DEFINE_RULES</span><span class="special">(</span><span class="identifier">foo</span><span class="special">);</span>
</pre>
<p>
        <code class="computeroutput"><span class="identifier">foo</span></code> matches the input if
        it can match two elements of the input in a row, but only if they are not
        the same value. Without locals, it's a lot harder to write parsers that have
        to track state as they parse.
      </p>
<h5>
<a name="boost_parser__proposed_.tutorial.more_about_rules.h9"></a>
        <span class="phrase"><a name="boost_parser__proposed_.tutorial.more_about_rules.parameters"></a></span><a class="link" href="more_about_rules.html#boost_parser__proposed_.tutorial.more_about_rules.parameters">Parameters</a>
      </h5>
<p>
        Sometimes, it is convenient to parameterize parsers. Consider this parsing
        rule from the <a href="https://yaml.org/spec/1.2/spec.html" target="_top">YAML 1.2</a>
        spec:
      </p>
<pre class="programlisting">[137] c-flow-sequence(n,c) ::= “[” s-separate(n,c)?
                               ns-s-flow-seq-entries(n,in-flow(c))? “]”
</pre>
<p>
        This YAML rule says that the parsing should proceed into two YAML subrules,
        both of which have these <code class="computeroutput"><span class="identifier">n</span></code>
        and <code class="computeroutput"><span class="identifier">c</span></code> parameters. It is certainly
        possible to transliterate these YAML parsing rules to something that uses
        unparameterized Boost.Parser <code class="computeroutput"><a class="link" href="../../boost/parser/rule.html" title="Struct template rule">rules</a></code>, but it is quite painful
        to do so.
      </p>
<p>
        You give parameters to a <code class="computeroutput"><a class="link" href="../../boost/parser/rule.html" title="Struct template rule">rule</a></code> by calling its <code class="computeroutput"><span class="identifier">with</span><span class="special">()</span></code>
        member. The values you pass to <code class="computeroutput"><span class="identifier">with</span><span class="special">()</span></code> are used to create a <code class="computeroutput"><a class="link" href="../../boost/parser/tuple.html" title="Type definition tuple">boost::parser::tuple</a></code> that is available in
        semantic actions attached to the rule, using <code class="computeroutput"><a class="link" href="../../boost/parser/_params.html" title="Function template _params">_params</a><span class="special">(</span><span class="identifier">ctx</span><span class="special">)</span></code>.
      </p>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">bp</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">parser</span><span class="special">;</span>

<span class="comment">// Declare our rules.</span>
<span class="identifier">bp</span><span class="special">::</span><span class="identifier">rule</span><span class="special">&lt;/*</span> <span class="special">...</span> <span class="special">*/&gt;</span> <span class="identifier">foo</span> <span class="special">=</span> <span class="string">"foo"</span><span class="special">;</span>
<span class="identifier">bp</span><span class="special">::</span><span class="identifier">rule</span><span class="special">&lt;/*</span> <span class="special">...</span> <span class="special">*/&gt;</span> <span class="identifier">bar</span> <span class="special">=</span> <span class="string">"bar"</span><span class="special">;</span>

<span class="comment">// Get the first parameter for this rule.</span>
<span class="keyword">auto</span> <span class="identifier">first_param</span> <span class="special">=</span> <span class="special">[](</span><span class="keyword">auto</span> <span class="special">&amp;</span> <span class="identifier">ctx</span><span class="special">)</span> <span class="special">{</span>
    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">hana</span><span class="special">::</span><span class="identifier">literals</span><span class="special">;</span>
    <span class="keyword">return</span> <span class="identifier">_params</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">)[</span><span class="number">0</span><span class="identifier">_c</span><span class="special">];</span>
<span class="special">};</span>
<span class="keyword">auto</span> <span class="keyword">const</span> <span class="identifier">foo_def</span> <span class="special">=</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">repeat</span><span class="special">(</span><span class="identifier">first_param</span><span class="special">)[</span><span class="char">' '</span><span class="identifier">_l</span><span class="special">];</span> <span class="comment">// Match ' ' the number of times indicated by the first parameter to foo.</span>

<span class="comment">// Assume that bar has a locals struct with a local_indent member, and</span>
<span class="comment">// that set_local_indent and local_indent are lambdas that respectively write</span>
<span class="comment">// and read _locals(ctx).local_indent.</span>

<span class="comment">// Parse an integer, and then pass that as a parameter to foo.</span>
<span class="keyword">auto</span> <span class="keyword">const</span> <span class="identifier">bar_def</span> <span class="special">=</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">int_</span><span class="special">[</span><span class="identifier">set_local_indent</span><span class="special">]</span> <span class="special">&gt;&gt;</span> <span class="identifier">foo</span><span class="special">.</span><span class="identifier">with</span><span class="special">(</span><span class="identifier">local_indent</span><span class="special">);</span>

<span class="identifier">BOOST_PARSER_DEFINE_RULES</span><span class="special">(</span><span class="identifier">foo</span><span class="special">,</span> <span class="identifier">bar</span><span class="special">);</span>
</pre>
<p>
        Passing parameters to <code class="computeroutput"><a class="link" href="../../boost/parser/rule.html" title="Struct template rule">rules</a></code> like this allows you
        to easily write parsers that change the way they parse depending on contextual
        data that they have already parsed.
      </p>
<h5>
<a name="boost_parser__proposed_.tutorial.more_about_rules.h10"></a>
        <span class="phrase"><a name="boost_parser__proposed_.tutorial.more_about_rules.the__globalname_alt__boost__parser___p___code__phrase_role__identifier___p__phrase___code___globalname__variable_template"></a></span><a class="link" href="more_about_rules.html#boost_parser__proposed_.tutorial.more_about_rules.the__globalname_alt__boost__parser___p___code__phrase_role__identifier___p__phrase___code___globalname__variable_template">The
        _p
        variable template</a>
      </h5>
<p>
        Getting at one of a rule's arguments and passing it as an argument to another
        parser can be very verbose. <code class="computeroutput"><a class="link" href="../../boost/parser/_p.html" title="Global _p">_p</a></code> is a variable template
        that allows you to refer to the <code class="computeroutput"><span class="identifier">n</span></code>th
        argument to the current rule, so that you can, in turn, pass it to one of
        the rule's subparsers. Using this, <code class="computeroutput"><span class="identifier">foo_def</span></code>
        above can be rewritten as:
      </p>
<pre class="programlisting"><span class="keyword">auto</span> <span class="keyword">const</span> <span class="identifier">foo_def</span> <span class="special">=</span> <span class="identifier">bp</span><span class="special">::</span><span class="identifier">repeat</span><span class="special">(</span><span class="identifier">bp</span><span class="special">::</span><span class="identifier">_p</span><span class="special">&lt;</span><span class="number">0</span><span class="special">&gt;)[</span><span class="char">' '</span><span class="identifier">_l</span><span class="special">];</span>
</pre>
<p>
        Using <code class="computeroutput"><a class="link" href="../../boost/parser/_p.html" title="Global _p">_p</a></code>
        can prevent you from having to write a bunch of lambdas that get each get
        an argument out of the parse context using <code class="computeroutput"><a class="link" href="../../boost/parser/_params.html" title="Function template _params">_params</a><span class="special">(</span><span class="identifier">ctx</span><span class="special">)[</span><span class="number">0</span><span class="identifier">_c</span><span class="special">]</span></code> or
        similar.
      </p>
</div>
<div class="copyright-footer">Copyright © 2020 T. Zachary Laine<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="the__parse____api.html"><img src="../../images/prev.png" alt="Prev"></a><a accesskey="u" href="../tutorial.html"><img src="../../images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../images/home.png" alt="Home"></a><a accesskey="n" href="algorithms_and_views_that_use_parsers.html"><img src="../../images/next.png" alt="Next"></a>
</div>
</body>
</html>
